#!/usr/bin/env python

import sys
import itertools

def num_bits(x):
    count = 0
    while x:
        x ^= x & -x
        count += 1
    return count

# Read the output of ./compute_cycles as pairs of integers.
def read_input():
    for line in sys.stdin:
        yield map(int, line.split())

# Sort the cycles first by the number of bits/dots in them, and
# secondly by their value (so top and left come first).
key = lambda x: (num_bits(x[0]), x[0])
sorted_pairs = sorted(read_input(), key=key)

# Split the pairs into two separate lists.
cycles, encircled_dots = zip(*sorted_pairs)

# Calculate the offsets where the next size of cycle begins.
offsets = []
offset = 0
for num_dots, group in itertools.groupby(cycles, key=num_bits):
    offsets.append((num_dots, offset))
    offset += len(list(group))

print '/* This file was automatically generated by', __file__, '*/'
print
print '#ifndef CYCLE_LITERALS_H'
print '#define CYCLE_LITERALS_H'
print
print '#define NUM_CYCLES {}'.format(len(cycles))
print
print '/* Cycles with N dots begin starting at CYCLES_OFFSET_N. */'
for n, offset in offsets:
    print '#define CYCLES_OFFSET_{} {}'.format(n, offset)
print
print '/* All cycles, sorted by the number of dots and then their position (top and left first). */'
print 'static const mask_t cycles[NUM_CYCLES] = {'
for x in cycles:
    print '    (mask_t){},'.format(x)
print '};'
print
print '/* The dots encircled by the corresponding cycle in cycles[]. */'
print 'static const mask_t encircled_dots[NUM_CYCLES] = {'
for x in encircled_dots:
    print '    (mask_t){},'.format(x)
print '};'
print '#endif'
